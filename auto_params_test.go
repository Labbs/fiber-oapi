package fiberoapi

import (
	"encoding/json"
	"testing"

	"github.com/gofiber/fiber/v2"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type AutoParamsTestInput struct {
	UserID   string  `path:"userId" validate:"required"`
	Name     string  `query:"name" validate:"required"`
	Age      int     `query:"age" validate:"omitempty,min=0,max=120"`
	Active   bool    `query:"active"`
	Score    float64 `query:"score"`
	Optional string  `query:"optional"`
}

type AutoParamsTestOutput struct {
	UserID   string  `json:"userId"`
	Name     string  `json:"name"`
	Age      int     `json:"age"`
	Active   bool    `json:"active"`
	Score    float64 `json:"score"`
	Optional string  `json:"optional"`
}

type AutoParamsTestError struct {
	StatusCode int    `json:"statusCode"`
	Message    string `json:"message"`
}

func TestAutoGeneratedParameters(t *testing.T) {
	app := fiber.New()
	oapi := New(app)

	// Register an endpoint with auto-generated parameters
	handler := func(c *fiber.Ctx, input AutoParamsTestInput) (AutoParamsTestOutput, AutoParamsTestError) {
		return AutoParamsTestOutput(input), AutoParamsTestError{}
	}

	Get(oapi, "/users/:userId", handler, OpenAPIOptions{
		OperationID: "getUserWithParams",
		Summary:     "Get user with auto-generated parameters",
	})

	// Generate OpenAPI spec
	spec := oapi.GenerateOpenAPISpec()

	// Convert to JSON for easier inspection
	specJSON, err := json.MarshalIndent(spec, "", "  ")
	require.NoError(t, err)
	t.Logf("Generated OpenAPI spec:\n%s", string(specJSON))

	// Check that the spec contains paths
	paths, ok := spec["paths"].(map[string]interface{})
	require.True(t, ok, "Spec should contain paths")

	// Check that our endpoint is present
	userPath, ok := paths["/users/{userId}"].(map[string]interface{})
	require.True(t, ok, "Should contain /users/{userId} path")

	// Check GET operation
	getOp, ok := userPath["get"].(map[string]interface{})
	require.True(t, ok, "Should contain GET operation")

	// Check parameters
	parameters, ok := getOp["parameters"].([]map[string]interface{})
	require.True(t, ok, "Should contain parameters")

	// Should have 5 parameters: userId (path), name, age, active, score, optional (all query except userId)
	assert.Len(t, parameters, 6, "Should have 6 parameters")

	// Check each parameter
	paramMap := make(map[string]map[string]interface{})
	for _, param := range parameters {
		if name, ok := param["name"].(string); ok {
			paramMap[name] = param
		}
	}

	// Check userId (path parameter)
	userIdParam, exists := paramMap["userId"]
	require.True(t, exists, "Should have userId parameter")
	assert.Equal(t, "path", userIdParam["in"], "userId should be a path parameter")
	assert.Equal(t, true, userIdParam["required"], "userId should be required")

	// Check name (required query parameter)
	nameParam, exists := paramMap["name"]
	require.True(t, exists, "Should have name parameter")
	assert.Equal(t, "query", nameParam["in"], "name should be a query parameter")
	assert.Equal(t, true, nameParam["required"], "name should be required")

	// Check age (optional query parameter)
	ageParam, exists := paramMap["age"]
	require.True(t, exists, "Should have age parameter")
	assert.Equal(t, "query", ageParam["in"], "age should be a query parameter")
	assert.Equal(t, false, ageParam["required"], "age should not be required")

	// Check active (boolean query parameter)
	activeParam, exists := paramMap["active"]
	require.True(t, exists, "Should have active parameter")
	assert.Equal(t, "query", activeParam["in"], "active should be a query parameter")
	assert.Equal(t, false, activeParam["required"], "active should not be required")

	// Check schema types
	if schema, ok := nameParam["schema"].(map[string]interface{}); ok {
		assert.Equal(t, "string", schema["type"], "name should be string type")
	}

	if schema, ok := ageParam["schema"].(map[string]interface{}); ok {
		assert.Equal(t, "integer", schema["type"], "age should be integer type")
	}

	if schema, ok := activeParam["schema"].(map[string]interface{}); ok {
		assert.Equal(t, "boolean", schema["type"], "active should be boolean type")
	}
}

func TestMergeWithManualParameters(t *testing.T) {
	app := fiber.New()
	oapi := New(app)

	type MergeTestInput struct {
		UserID string `path:"userId" validate:"required"`
		Name   string `query:"name" validate:"required"`
		Filter string `query:"filter"`
	}

	type MergeTestOutput struct {
		UserID string `json:"userId"`
		Name   string `json:"name"`
		Filter string `json:"filter"`
	}

	type MergeTestError struct {
		StatusCode int    `json:"statusCode"`
		Message    string `json:"message"`
	}

	handler := func(c *fiber.Ctx, input MergeTestInput) (MergeTestOutput, MergeTestError) {
		return MergeTestOutput(input), MergeTestError{}
	}

	// Register with manual parameters that should override auto-generated ones
	Get(oapi, "/users/:userId", handler, OpenAPIOptions{
		OperationID: "getUserWithMergedParams",
		Summary:     "Get user with merged parameters",
		Parameters: []map[string]interface{}{
			{
				"name":        "name",
				"in":          "query",
				"required":    false, // Override the required from struct tag
				"description": "Custom description for name parameter",
				"schema": map[string]interface{}{
					"type":    "string",
					"pattern": "^[a-zA-Z]+$", // Add custom validation
				},
			},
			{
				"name":        "customParam",
				"in":          "query",
				"required":    false,
				"description": "A completely manual parameter",
				"schema": map[string]interface{}{
					"type": "string",
				},
			},
		},
	})

	spec := oapi.GenerateOpenAPISpec()

	// Check parameters
	paths := spec["paths"].(map[string]interface{})
	userPath := paths["/users/{userId}"].(map[string]interface{})
	getOp := userPath["get"].(map[string]interface{})
	parameters := getOp["parameters"].([]map[string]interface{})

	// Should have 4 parameters: userId (auto), name (manual override), filter (auto), customParam (manual)
	assert.Len(t, parameters, 4, "Should have 4 parameters")

	// Check that manual parameter overrides auto-generated one
	paramMap := make(map[string]map[string]interface{})
	for _, param := range parameters {
		if name, ok := param["name"].(string); ok {
			paramMap[name] = param
		}
	}

	// Verify manual override
	nameParam := paramMap["name"]
	assert.Equal(t, false, nameParam["required"], "Manual parameter should override auto-generated required flag")
	assert.Equal(t, "Custom description for name parameter", nameParam["description"], "Manual description should be used")

	// Verify auto-generated parameters are still present
	_, hasUserId := paramMap["userId"]
	_, hasFilter := paramMap["filter"]
	_, hasCustom := paramMap["customParam"]

	assert.True(t, hasUserId, "Auto-generated userId should be present")
	assert.True(t, hasFilter, "Auto-generated filter should be present")
	assert.True(t, hasCustom, "Manual customParam should be present")
}

func TestNoParametersWhenNoStruct(t *testing.T) {
	app := fiber.New()
	oapi := New(app)

	type SimpleOutput struct {
		Message string `json:"message"`
	}

	type SimpleError struct {
		StatusCode int    `json:"statusCode"`
		Message    string `json:"message"`
	}

	// Register endpoint without input struct
	Get(oapi, "/simple", func(c *fiber.Ctx, input struct{}) (SimpleOutput, SimpleError) {
		return SimpleOutput{Message: "hello"}, SimpleError{}
	}, OpenAPIOptions{
		OperationID: "simpleEndpoint",
		Summary:     "Simple endpoint without parameters",
	})

	spec := oapi.GenerateOpenAPISpec()

	paths := spec["paths"].(map[string]interface{})
	simplePath := paths["/simple"].(map[string]interface{})
	getOp := simplePath["get"].(map[string]interface{})

	// Should not have parameters
	_, hasParams := getOp["parameters"]
	assert.False(t, hasParams, "Should not have parameters when no input struct")
}
