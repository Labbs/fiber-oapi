package fiberoapi

import (
	"fmt"
	"net/http"
	"reflect"
	"strconv"
	"strings"

	"github.com/gofiber/fiber/v2"
)

// DefaultConfig returns the default configuration
func DefaultConfig() Config {
	return Config{
		EnableValidation:  true,
		EnableOpenAPIDocs: true,
		OpenAPIDocsPath:   "/docs",
		OpenAPIJSONPath:   "/openapi.json",
	}
}

// New creates a new OApiApp with optional configuration
func New(app *fiber.App, config ...Config) *OApiApp {
	// Use default config if none provided
	cfg := DefaultConfig()
	if len(config) > 0 {
		cfg = config[0]
	}

	oapi := &OApiApp{
		f:          app,
		operations: make([]OpenAPIOperation, 0),
		config:     cfg,
	}

	// Automatically setup documentation routes if enabled
	if cfg.EnableOpenAPIDocs {
		oapi.setupDocsRoutes()
	}

	return oapi
}

// setupDocsRoutes automatically configures the documentation routes
func (o *OApiApp) setupDocsRoutes() {
	// Serve OpenAPI JSON specification
	o.f.Get(o.Config().OpenAPIJSONPath, func(c *fiber.Ctx) error {
		spec := o.GenerateOpenAPISpec()
		c.Set("Content-Type", "application/json")
		return c.JSON(spec)
	})

	// Serve Redoc documentation
	o.f.Get(o.Config().OpenAPIDocsPath, func(c *fiber.Ctx) error {
		html := generateRedocHTML(o.Config().OpenAPIJSONPath, "API Documentation")
		c.Set("Content-Type", "text/html")
		return c.SendString(html)
	})

	// Handle trailing slash redirect
	if !strings.HasSuffix(o.Config().OpenAPIDocsPath, "/") {
		o.f.Get(o.Config().OpenAPIDocsPath+"/", func(c *fiber.Ctx) error {
			return c.Redirect(o.Config().OpenAPIDocsPath)
		})
	}
}

// GetOperations returns all registered operations (useful for testing and documentation generation)
func (o *OApiApp) GetOperations() []OpenAPIOperation {
	return o.operations
}

// GenerateOpenAPISpec generates a complete OpenAPI 3.0 specification
func (o *OApiApp) GenerateOpenAPISpec() map[string]interface{} {
	spec := map[string]interface{}{
		"openapi": "3.0.0",
		"info": map[string]interface{}{
			"title":       "Fiber OpenAPI",
			"version":     "1.0.0",
			"description": "API documentation generated by fiber-oapi",
		},
		"paths":      make(map[string]interface{}),
		"components": make(map[string]interface{}),
	}

	paths := spec["paths"].(map[string]interface{})
	components := spec["components"].(map[string]interface{})
	schemas := make(map[string]interface{})
	components["schemas"] = schemas

	for _, op := range o.operations {
		// Convert Fiber path format (:param) to OpenAPI format ({param})
		openAPIPath := convertFiberPathToOpenAPI(op.Path)

		if paths[openAPIPath] == nil {
			paths[openAPIPath] = make(map[string]interface{})
		}

		pathItem := paths[openAPIPath].(map[string]interface{})

		// Copy the options and enhance them with auto-generated schemas
		enhancedOptions := make(map[string]interface{})

		// Copy existing options
		if op.Options.OperationID != "" {
			enhancedOptions["operationId"] = op.Options.OperationID
		}
		if op.Options.Summary != "" {
			enhancedOptions["summary"] = op.Options.Summary
		}
		if op.Options.Description != "" {
			enhancedOptions["description"] = op.Options.Description
		}
		if len(op.Options.Tags) > 0 {
			enhancedOptions["tags"] = op.Options.Tags
		}
		if len(op.Options.Parameters) > 0 {
			enhancedOptions["parameters"] = op.Options.Parameters
		}

		// Add request body schema for POST/PUT methods
		if op.Method == "POST" || op.Method == "PUT" || op.Method == "PATCH" {
			if op.InputType != nil {
				inputSchemaName := getTypeName(op.InputType)
				inputSchema := generateSchema(op.InputType)
				schemas[inputSchemaName] = inputSchema

				enhancedOptions["requestBody"] = map[string]interface{}{
					"required": true,
					"content": map[string]interface{}{
						"application/json": map[string]interface{}{
							"schema": map[string]interface{}{
								"$ref": "#/components/schemas/" + inputSchemaName,
							},
						},
					},
				}
			}
		}

		// Add response schemas
		responses := make(map[string]interface{})

		// Success response (200)
		if op.OutputType != nil {
			outputSchemaName := getTypeName(op.OutputType)
			outputSchema := generateSchema(op.OutputType)
			schemas[outputSchemaName] = outputSchema

			responses["200"] = map[string]interface{}{
				"description": "Successful response",
				"content": map[string]interface{}{
					"application/json": map[string]interface{}{
						"schema": map[string]interface{}{
							"$ref": "#/components/schemas/" + outputSchemaName,
						},
					},
				},
			}
		}

		// Error response (400/500)
		if op.ErrorType != nil && !isEmptyStruct(op.ErrorType) {
			errorSchemaName := getTypeName(op.ErrorType)
			errorSchema := generateSchema(op.ErrorType)
			schemas[errorSchemaName] = errorSchema

			responses["400"] = map[string]interface{}{
				"description": "Validation error",
				"content": map[string]interface{}{
					"application/json": map[string]interface{}{
						"schema": map[string]interface{}{
							"$ref": "#/components/schemas/" + errorSchemaName,
						},
					},
				},
			}
		}

		enhancedOptions["responses"] = responses
		pathItem[strings.ToLower(op.Method)] = enhancedOptions
	}

	return spec
}

// convertFiberPathToOpenAPI converts Fiber path format to OpenAPI format
// Example: /users/:id/posts/:postId -> /users/{id}/posts/{postId}
func convertFiberPathToOpenAPI(fiberPath string) string {
	// Replace :param with {param}
	parts := strings.Split(fiberPath, "/")

	for i, part := range parts {
		if strings.HasPrefix(part, ":") {
			parts[i] = "{" + part[1:] + "}"
		}
	}

	return strings.Join(parts, "/")
}

// getTypeName returns the name of a Go type for use in OpenAPI schema names
func getTypeName(t reflect.Type) string {
	if t == nil {
		return "EmptyObject"
	}

	// Handle pointers
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	name := t.Name()
	if name == "" {
		// For anonymous structs, use the package path + "AnonymousStruct"
		if t.Kind() == reflect.Struct {
			return "AnonymousStruct"
		}
		return t.Kind().String()
	}

	return name
}

// generateSchema generates an OpenAPI schema from a Go type
func generateSchema(t reflect.Type) map[string]interface{} {
	if t == nil {
		return map[string]interface{}{
			"type": "object",
		}
	}

	// Handle pointers
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	schema := make(map[string]interface{})

	switch t.Kind() {
	case reflect.Struct:
		schema["type"] = "object"
		properties := make(map[string]interface{})
		required := []string{}

		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			if !field.IsExported() {
				continue
			}

			// Get JSON tag name
			jsonTag := field.Tag.Get("json")
			if jsonTag == "-" {
				continue
			}

			fieldName := field.Name
			if jsonTag != "" {
				parts := strings.Split(jsonTag, ",")
				if parts[0] != "" {
					fieldName = parts[0]
				}
			}

			// Generate field schema
			fieldSchema := generateFieldSchema(field.Type)

			// Add validation info from tags
			if validateTag := field.Tag.Get("validate"); validateTag != "" {
				addValidationToSchema(fieldSchema, validateTag)

				// Check if field is required
				if strings.Contains(validateTag, "required") {
					required = append(required, fieldName)
				}
			}

			// Add description from path/query tags
			if pathTag := field.Tag.Get("path"); pathTag != "" {
				fieldSchema["description"] = "Path parameter: " + pathTag
			} else if queryTag := field.Tag.Get("query"); queryTag != "" {
				fieldSchema["description"] = "Query parameter: " + queryTag
			}

			properties[fieldName] = fieldSchema
		}

		schema["properties"] = properties
		if len(required) > 0 {
			schema["required"] = required
		}

	case reflect.String:
		schema["type"] = "string"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		schema["type"] = "integer"
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		schema["type"] = "integer"
		schema["minimum"] = 0
	case reflect.Float32, reflect.Float64:
		schema["type"] = "number"
	case reflect.Bool:
		schema["type"] = "boolean"
	case reflect.Slice:
		schema["type"] = "array"
		schema["items"] = generateFieldSchema(t.Elem())
	default:
		schema["type"] = "object"
	}

	return schema
}

// generateFieldSchema generates schema for a struct field
func generateFieldSchema(t reflect.Type) map[string]interface{} {
	schema := make(map[string]interface{})

	// Handle pointers
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	switch t.Kind() {
	case reflect.String:
		schema["type"] = "string"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		schema["type"] = "integer"
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		schema["type"] = "integer"
		schema["minimum"] = 0
	case reflect.Float32, reflect.Float64:
		schema["type"] = "number"
	case reflect.Bool:
		schema["type"] = "boolean"
	case reflect.Slice:
		schema["type"] = "array"
		schema["items"] = generateFieldSchema(t.Elem())
	case reflect.Struct:
		// For nested structs, reference the type name
		typeName := getTypeName(t)
		schema["$ref"] = "#/components/schemas/" + typeName
	default:
		schema["type"] = "object"
	}

	return schema
}

// addValidationToSchema adds validation constraints to schema based on validate tags
func addValidationToSchema(schema map[string]interface{}, validateTag string) {
	rules := strings.Split(validateTag, ",")

	for _, rule := range rules {
		rule = strings.TrimSpace(rule)

		if rule == "required" {
			// Required is handled at the object level
			continue
		} else if strings.HasPrefix(rule, "min=") {
			if val := strings.TrimPrefix(rule, "min="); val != "" {
				if schema["type"] == "string" {
					schema["minLength"] = parseIntOrZero(val)
				} else if schema["type"] == "integer" || schema["type"] == "number" {
					schema["minimum"] = parseIntOrZero(val)
				}
			}
		} else if strings.HasPrefix(rule, "max=") {
			if val := strings.TrimPrefix(rule, "max="); val != "" {
				if schema["type"] == "string" {
					schema["maxLength"] = parseIntOrZero(val)
				} else if schema["type"] == "integer" || schema["type"] == "number" {
					schema["maximum"] = parseIntOrZero(val)
				}
			}
		} else if rule == "email" {
			schema["format"] = "email"
		} else if rule == "uuid4" {
			schema["format"] = "uuid"
		} else if rule == "url" {
			schema["format"] = "uri"
		} else if strings.HasPrefix(rule, "oneof=") {
			if val := strings.TrimPrefix(rule, "oneof="); val != "" {
				values := strings.Split(val, " ")
				schema["enum"] = values
			}
		}
	}
}

// parseIntOrZero parses a string to int, returns 0 if parsing fails
func parseIntOrZero(s string) int {
	if val, err := strconv.Atoi(s); err == nil {
		return val
	}
	return 0
}

// isEmptyStruct checks if a type represents an empty struct
func isEmptyStruct(t reflect.Type) bool {
	if t == nil {
		return true
	}

	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	return t.Kind() == reflect.Struct && t.NumField() == 0
}

// Method defines a generic method for registering HTTP operations with OpenAPI documentation
func Method[TInput any, TOutput any, TError any](
	router OApiRouter, // Interface instead of *OApiApp
	m string,
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	app := router.GetApp()
	fullPath := router.GetPrefix() + path

	// Validate path parameters with the input struct
	if err := validatePathParams[TInput](fullPath); err != nil {
		panic(fmt.Sprintf("Path validation failed for %s: %v", fullPath, err))
	}

	// Register the operation for OpenAPI documentation with type information
	var inputZero TInput
	var outputZero TOutput
	var errorZero TError

	app.operations = append(app.operations, OpenAPIOperation{
		Method:     m,
		Path:       fullPath,
		Options:    options,
		InputType:  reflect.TypeOf(inputZero),
		OutputType: reflect.TypeOf(outputZero),
		ErrorType:  reflect.TypeOf(errorZero),
	})

	// Wrapper
	fiberHandler := func(c *fiber.Ctx) error {
		input, err := parseInput[TInput](app, c, fullPath)
		if err != nil {
			return c.Status(400).JSON(fiber.Map{
				"error":   "Validation failed",
				"details": err.Error(),
			})
		}

		output, customErr := handler(c, input)

		if !isZero(customErr) {
			return handleCustomError(c, customErr)
		}

		return c.JSON(output)
	}

	app.f.Add(m, fullPath, fiberHandler)
}

// Get defines a GET operation for the OpenAPI documentation
func Get[TInput any, TOutput any, TError any](
	router OApiRouter, // Now accepts both *OApiApp and *OApiGroup
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	Method(router, http.MethodGet, path, handler, options)
}

// Post defines a POST operation for the OpenAPI documentation
func Post[TInput any, TOutput any, TError any](
	router OApiRouter, // Now accepts both *OApiApp and *OApiGroup
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	Method(router, http.MethodPost, path, handler, options)
}

// Put defines a PUT operation for the OpenAPI documentation
func Put[TInput any, TOutput any, TError any](
	router OApiRouter, // Now accepts both *OApiApp and *OApiGroup
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	Method(router, http.MethodPut, path, handler, options)
}

// Delete defines a DELETE operation for the OpenAPI documentation
func Delete[TInput any, TOutput any, TError any](
	router OApiRouter, // Now accepts both *OApiApp and *OApiGroup
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	Method(router, http.MethodDelete, path, handler, options)
}

// Head defines a HEAD operation for the OpenAPI documentation
func Head[TInput any, TOutput any, TError any](
	router OApiRouter, // Now accepts both *OApiApp and *OApiGroup
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	Method(router, http.MethodHead, path, handler, options)
}

// Patch defines a PATCH operation for the OpenAPI documentation
func Patch[TInput any, TOutput any, TError any](
	router OApiRouter, // Now accepts both *OApiApp and *OApiGroup
	path string,
	handler HandlerFunc[TInput, TOutput, TError],
	options OpenAPIOptions,
) {
	Method(router, http.MethodPatch, path, handler, options)
}
